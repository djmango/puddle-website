So, Puddle is supposed to be a fully decentralized system based on an IOTA-like DAG. This DAG, known as the Puddle is the core structure for the rest of the project. Puddle is a separate project from it's head layers. 

Essentially, what a Puddle node is supposed to do is maintain a list of all peers, with basic information about that peer, such as address, account value and trust, and then broadcast a hash of all the info to it's peers. If a peer has a different hash, the info is compared between peers. Both peers will contact every node on the list and if there are any dead ones, will remove them from the list. All alive nodes will be added to a list and merged between the two peers. This process makes sure that the entire network is known. There must be a seed peer when starting a node without any list info, so that the new node can connect to all peers that it can.

What if, instead of a normal DAG, we use the same consensus idea, where 51% of the entire network must agree that a certain transaction happened. Since every transaction has a definitive integer of trust, in order for it to be added to the final ledger for a reset, where all the transactions are deleted and a final list of all non-empty accounts is made.

The issue is, to reach consensus, we need to decide who is part of the network. With block chain, everyone is part of the network, but the issue is, here, its not critical that everyone has the same ledger. Rather, it's a implemented feature that not everyone has the same ledger.

Ok I think I got it. Imagine an attacker wanted to buy bread. The attacker wants to send currency they don't have to the bread vendor. To do the transaction, the attacker has to hash their puddle. If no future transactions verify that the hash of that puddle matches theirs, the score doesn't go up. If the attacker makes new nodes and verifies it themselves, those nodes do not get verified by anyone on the real network. So, you want to be connected to as many nodes as possible. If you are not connected to a node, it won't go through. The key is m2m, p2p, h2h. Both the receiver and sender must be directly connected. THATS THE FUCKING KEY!

When you receive a transaction (tx) , the node validates the tx syntax - enough PoW, timestamp, value format etc. But, you don't validate the semantics. i. e. The signature validation and accounting. This semantic validation is done once you want to send a tx and is part of the tip selection process. You traverse the tangle in a random walk, and for each tx you meet, you may check if the cone (all the descendants of that tx) is valid, i. e. The ledger is consistent, if not you stop before it, if it is consistent, continue walking. Nodes don't actually need to check the whole cone, as they can have snapshots of the puddle state.